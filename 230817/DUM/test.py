a = "Hi Hello"
print(a.upper()) # 대문자로 변환
print(a.lower()) # 소문자로 변환

######################################################################

a= 1.2
b=1.4
c=2.6
print(a+b==2.6)
print(f"a의 메모리 위치 주소값 (임시) id(a) : {id(a)}")
print(f"b의 메모리 위치 주소값 (임시) id(b) : {id(b)}")
print(f"a와 b의 메모리 주소값 비교 a is b : {a is b}")

######################################################################

# 이중 리스트에서 각 요소의 메모리 위치 주소값 확인
a = [[1,2],[3,4]] # 2차원 배열, 2 x 2
# a[0] = [1,2]
# a[1] = [3,4]
# a[0][1] = 2
print(f"a 리스트의 a[0]의 메모리 위치 주소값 확인: {id(a[0])}")
print(f"a 리스트의 a[0]의 메모리 위치 주소값 확인: {id(a[1])}")
print(f"a 리스트의 a[0][0]의 메모리 위치 주소값 확인: {id(a[0][0])}")
print(f"a 리스트의 a[0][1]의 메모리 위치 주소값 확인: {id(a[0][1])}")

######################################################################

def f(x):
    y=x
    x=5
    return y*y
x = 3

######################################################################

def f(x):
   # y, z (매개변수로 사용했음), 지역변수 사용중
    global z
    z = 10 # ㅎ마수 내부의 변수이지만 전역으로 사용함

    # global x , 이미 전역으로 사용된 변수를 함수 내부에서 재선언이 안됨
    # 자바스크립트로 치면, 기존에는 var 변수 타입으로 재선언 및 재할당등이 가능하지만
    # es6 버전 이후로는 let, const를 이용해서 해당 블록 범위서 재선언이 안되게 함
    #  파이썬에서도 해당 블록 범위에서 전역으로 재선언을 막고 있다
    y = x
    y = 3 
    return y * y

######################################################################

# 가변인수 *

print("가변인수 테스트")
def a(*args):
    # x, y : 일반적인 변수타입
    # *z : 가변 인수임
    # 언패킹, 여러개 값을 각각의 변수에 나눠담는 과정
    # 디스트럭쳐링 
    x,y,*z = args
    return x,y,z
print(a(1,2,3,4,5))

######################################################################

# 키워드 가변 인자 -> **를 사용해서 정의하면 됨
def c(**abcd):
    
   print(abcd)

# 호출 구분자, =
c(first = 1, second =2)

a= [1,2,3]
# 리스트 -> [1,2,3]
print(f"리스트 형식 출력 해보기: {a}")

b= tuple(a)
# 튜플 -> (1,2,3)
print(f"튜플 형식 출력해보기 {b}")

c = {'key' : 'value'}
# 딕션너리 -> {'a' : 1}
print(f"딕셔너리 형식 출력해보기 {c}")

a2 = [1,1,2,3]
d = set(a2)
print(f"set(집합:중복불가) 형식 출력해보기 {d}")


######################################################################
